apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: rabbitmq
  namespace: rabbitmq
spec:
  values:
    ## @param clusterDomain Kubernetes Cluster Domain
    ##
    clusterDomain: cluster.local

    ## RabbitMQ Authentication parameters
    ##
    auth:
      ## @param auth.username RabbitMQ application username
      ## ref: https://github.com/bitnami/containers/tree/main/bitnami/rabbitmq#environment-variables
      ##
      username: guest
      ## @param auth.password RabbitMQ application password
      ## ref: https://github.com/bitnami/containers/tree/main/bitnami/rabbitmq#environment-variables
      ##
      password: "guest"
      tls:
        enabled: false
        autoGenerated: false
        failIfNoPeerCert: true
        sslOptionsVerify: verify_peer
        sslOptionsPassword:
          enabled: false
          existingSecret: ""
          key: ""
          password: ""
        caCertificate: ""
        serverCertificate: ""
        serverKey: ""
        existingSecret: ""
        existingSecretFullChain: false
        overrideCaCertificate: ""

    ## @param plugins List of default plugins to enable (should only be altered to remove defaults; for additional plugins use `extraPlugins`)
    ##
    plugins: "rabbitmq_management rabbitmq_peer_discovery_k8s"

    ## @param communityPlugins List of Community plugins (URLs) to be downloaded during container initialization
    ## Combine it with extraPlugins to also enable them.
    ##
    communityPlugins: ""
    ## @param extraPlugins Extra plugins to enable (single string containing a space-separated list)
    ## Use this instead of `plugins` to add new plugins
    ##
    extraPlugins: "rabbitmq_auth_backend_ldap"
    configuration: |-
      ## Username and password
      default_user = {{ .Values.auth.username }}
      {{- if and (not .Values.auth.securePassword) .Values.auth.password }}
      default_pass = {{ .Values.auth.password }}
      {{- end }}
      {{- if .Values.clustering.enabled }}
      ## Clustering
      ##
      cluster_name = {{ default (include "common.names.fullname" .) .Values.clustering.name }}
      cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
      cluster_formation.k8s.host = kubernetes.default
      cluster_formation.k8s.address_type = {{ .Values.clustering.addressType }}
      {{- $svcName := printf "%s-%s" (include "common.names.fullname" .) (default "headless" .Values.servicenameOverride) }}
      cluster_formation.k8s.service_name = {{ $svcName }}
      cluster_formation.k8s.hostname_suffix = .{{ $svcName }}.{{ include "common.names.namespace" . }}.svc.{{ .Values.clusterDomain }}
      cluster_formation.node_cleanup.interval = 10
      cluster_formation.node_cleanup.only_log_warning = true
      cluster_partition_handling = {{ .Values.clustering.partitionHandling }}
      {{- end }}
      {{ if and .Values.clustering.enabled .Values.loadDefinition.enabled }}
      cluster_formation.target_cluster_size_hint = {{ .Values.replicaCount }}
      {{ end }}
      {{- if .Values.loadDefinition.enabled }}
      load_definitions = {{ .Values.loadDefinition.file }}
      {{- end }}
      # queue master locator
      queue_master_locator = {{ .Values.queue_master_locator }}
      # enable loopback user
      {{- if not (empty .Values.auth.username) }}
      loopback_users.{{ .Values.auth.username }} = {{ .Values.auth.enableLoopbackUser }}
      {{- else}}
      loopback_users.guest = {{ .Values.auth.enableLoopbackUser }}
      {{- end }}
      {{ template "rabbitmq.extraConfiguration" . }}
      {{- if .Values.auth.tls.enabled }}
      ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}
      listeners.ssl.default = {{ .Values.service.ports.amqpTls }}
      ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}
      ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem
      ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem
      ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem
      {{- if .Values.auth.tls.sslOptionsPassword.enabled }}
      ssl_options.password = {{ include "common.secrets.passwords.manage" (dict "secret" .Values.auth.tls.sslOptionsPassword.existingSecret "key" .Values.auth.tls.sslOptionsPassword.key "providedValues" (list "auth.tls.sslOptionsPassword.password") "skipB64enc" true "failOnNew" false "context" $) }}
      {{- end }}
      {{- end }}
      {{- if .Values.ldap.enabled }}
      auth_backends.1.authn = ldap
      auth_backends.1.authz = {{ ternary "ldap" "internal" .Values.ldap.authorisationEnabled }}
      auth_backends.2 = internal
      {{- $host :=  list }}
      {{- $port :=  ternary 636 389 .Values.ldap.tls.enabled }}
      {{- if .Values.ldap.uri }}
      {{- $hostPort := get (urlParse .Values.ldap.uri) "host" }}
      {{- $host = list (index (splitList ":" $hostPort) 0) -}}
      {{- if (contains ":" $hostPort) }}
      {{- $port = index (splitList ":" $hostPort) 1 -}}
      {{- end }}
      {{- end }}
      {{- range $index, $server := concat $host .Values.ldap.servers }}
      auth_ldap.servers.{{ add $index 1 }} = {{ $server }}
      {{- end }}
      auth_ldap.port = {{ coalesce .Values.ldap.port $port }}
      {{- if or .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}
      auth_ldap.user_dn_pattern = {{ coalesce .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}
      {{- end }}
      {{- if .Values.ldap.basedn }}
      auth_ldap.dn_lookup_base = {{ .Values.ldap.basedn }}
      {{- end }}
      {{- if .Values.ldap.uidField }}
      auth_ldap.dn_lookup_attribute = {{ .Values.ldap.uidField }}
      {{- end }}
      {{- if .Values.ldap.binddn }}
      auth_ldap.dn_lookup_bind.user_dn = {{ .Values.ldap.binddn }}
      auth_ldap.dn_lookup_bind.password = {{ required "'ldap.bindpw' is required when 'ldap.binddn' is defined" .Values.ldap.bindpw }}
      {{- end }}
      {{- if .Values.ldap.tls.enabled }}
      auth_ldap.use_ssl = {{ not .Values.ldap.tls.startTls }}
      auth_ldap.use_starttls = {{ .Values.ldap.tls.startTls }}
      {{- if .Values.ldap.tls.CAFilename }}
      auth_ldap.ssl_options.cacertfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.CAFilename }}
      {{- end }}
      {{- if .Values.ldap.tls.certFilename }}
      auth_ldap.ssl_options.certfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.certFilename }}
      auth_ldap.ssl_options.keyfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ required "'ldap.tls.certKeyFilename' is required when 'ldap.tls.certFilename' is defined" .Values.ldap.tls.certKeyFilename }}
      {{- end }}
      {{- if .Values.ldap.tls.skipVerify }}
      auth_ldap.ssl_options.verify = verify_none
      auth_ldap.ssl_options.fail_if_no_peer_cert = false
      {{- else if .Values.ldap.tls.verify }}
      auth_ldap.ssl_options.verify = {{ .Values.ldap.tls.verify }}
      {{- end }}
      {{- end }}
      {{- end }}
      ## Prometheus metrics
      ##
      prometheus.tcp.port = {{ .Values.containerPorts.metrics }}
      {{- if .Values.memoryHighWatermark.enabled }}
      ## Memory Threshold
      ##
      {{- if (dig "limits" "memory" "" .Values.resources) }}
      total_memory_available_override_value = {{ include "rabbitmq.toBytes" (dig "limits" "memory" "" .Values.resources) }}
      {{- end }}
      {{- if (eq .Values.memoryHighWatermark.type "absolute") }}
      vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ include "rabbitmq.toBytes" .Values.memoryHighWatermark.value }}
      {{- else if (eq .Values.memoryHighWatermark.type "relative") }}
      vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ .Values.memoryHighWatermark.value }}
      {{- end }}
      {{- end }}
      {{- if .Values.tcpListenOptions.enabled }}
      ## TCP Listen Options
      ##
      tcp_listen_options.backlog = {{ .Values.tcpListenOptions.backlog }}
      tcp_listen_options.nodelay = {{ .Values.tcpListenOptions.nodelay }}
      tcp_listen_options.linger.on      = {{ .Values.tcpListenOptions.linger.lingerOn }}
      tcp_listen_options.linger.timeout = {{ .Values.tcpListenOptions.linger.timeout }}
      tcp_listen_options.keepalive = {{ .Values.tcpListenOptions.keepalive }}
      {{- end }}

    extraConfiguration: |-
      #default_vhost = {{ .Release.Namespace }}-vhost
      #disk_free_limit.absolute = 50MB

    ## @param replicaCount Number of RabbitMQ replicas to deploy
    ##
    replicaCount: 3

    ingress:
      enabled: true
      path: /
      pathType: ImplementationSpecific
      hostname: rabbitmq.kindcluster.dev
      annotations:
        cert-manager.io/cluster-issuer: mkcert-issuer

      tls: true
      secrets: []
      ## @param ingress.ingressClassName IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
      ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
      ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
      ##
      ingressClassName: nginx

    networkPolicy:
      ## @param networkPolicy.enabled Specifies whether a NetworkPolicy should be created
      ##
      enabled: false

      ## Custom PrometheusRule to be defined
      ## The value is evaluated as a template, so, for example, the value can depend on .Release or .Chart
      ## ref: https://github.com/coreos/prometheus-operator#customresourcedefinitions
      ##
      prometheusRule:
        enabled: true
